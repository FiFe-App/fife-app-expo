create extension if not exists "http" with schema "extensions";

create extension if not exists "pgjwt" with schema "extensions";

create extension if not exists "pgroonga" with schema "extensions";

create extension if not exists "postgis" with schema "extensions";

create extension if not exists "vector" with schema "extensions";

create extension if not exists "wrappers" with schema "extensions";

create schema if not exists "postgis";

create schema if not exists "private";

create type "public"."contact_type" as enum ('TEL', 'EMAIL', 'WEB', 'OTHER', 'INSTAGRAM', 'FACEBOOK', 'PLACE');


  create table "private"."email_log" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid,
    "message" character varying,
    "type" text
      );


alter table "private"."email_log" enable row level security;


  create table "private"."keys" (
    "id" bigint generated by default as identity not null,
    "key" text not null,
    "value" text not null
      );



  create table "public"."buziness" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "title" text not null,
    "description" character varying not null,
    "author" uuid not null,
    "images" text[],
    "location" extensions.geography,
    "radius" real,
    "defaultContact" bigint,
    "embedding" extensions.vector(512),
    "embedding_text" character varying
      );


alter table "public"."buziness" enable row level security;


  create table "public"."buzinessRecommendations" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "author" uuid not null,
    "buziness_id" bigint not null
      );


alter table "public"."buzinessRecommendations" enable row level security;


  create table "public"."comments" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "text" text not null,
    "author" uuid not null,
    "key" text not null,
    "image" text
      );


alter table "public"."comments" enable row level security;


  create table "public"."contacts" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "type" public.contact_type not null,
    "data" text not null,
    "title" character varying,
    "public" boolean,
    "author" uuid not null
      );


alter table "public"."contacts" enable row level security;


  create table "public"."eventResponses" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "value" smallint not null,
    "user_id" uuid not null default auth.uid(),
    "event_id" bigint not null
      );


alter table "public"."eventResponses" enable row level security;


  create table "public"."events" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "title" text not null,
    "date" timestamp without time zone not null,
    "duration" text,
    "locationName" text not null,
    "description" character varying,
    "location" extensions.geometry,
    "author" uuid not null
      );


alter table "public"."events" enable row level security;


  create table "public"."messages" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "author" uuid not null,
    "text" text not null,
    "to" uuid
      );


alter table "public"."messages" enable row level security;


  create table "public"."posts" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "categories" character varying not null,
    "text" character varying not null,
    "author" uuid not null,
    "location" extensions.geography
      );


alter table "public"."posts" enable row level security;


  create table "public"."profileRecommendations" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "author" uuid not null,
    "profile_id" uuid not null
      );


alter table "public"."profileRecommendations" enable row level security;


  create table "public"."profiles" (
    "id" uuid not null,
    "updated_at" timestamp with time zone,
    "username" text,
    "full_name" text not null,
    "avatar_url" text,
    "website" text,
    "created_at" timestamp without time zone default now(),
    "viewed_functions" text[],
    "location" extensions.geography
      );


alter table "public"."profiles" enable row level security;

CREATE UNIQUE INDEX email_log_pkey ON private.email_log USING btree (id);

CREATE UNIQUE INDEX keys_pkey ON private.keys USING btree (id);

CREATE UNIQUE INDEX "buzinessRecommendations_id_key" ON public."buzinessRecommendations" USING btree (id);

CREATE UNIQUE INDEX "buzinessRecommendations_pkey" ON public."buzinessRecommendations" USING btree (id);

CREATE INDEX buziness_embedding_idx ON public.buziness USING hnsw (embedding extensions.vector_ip_ops);

CREATE UNIQUE INDEX buziness_id_key ON public.buziness USING btree (id);

CREATE UNIQUE INDEX buziness_pkey ON public.buziness USING btree (id);

CREATE INDEX comments_key_idx ON public.comments USING hash (key);

CREATE UNIQUE INDEX comments_pkey ON public.comments USING btree (id);

CREATE UNIQUE INDEX contacts_pkey ON public.contacts USING btree (id);

CREATE UNIQUE INDEX "eventResponses_pkey" ON public."eventResponses" USING btree (id);

CREATE UNIQUE INDEX event_responses_user_event_unique ON public."eventResponses" USING btree (event_id, user_id);

CREATE UNIQUE INDEX events_pkey ON public.events USING btree (id);

CREATE INDEX ix_memos_content ON public.buziness USING pgroonga (title);

CREATE UNIQUE INDEX messages_pkey ON public.messages USING btree (id);

CREATE UNIQUE INDEX posts_pkey ON public.posts USING btree (id);

CREATE UNIQUE INDEX "profileRecommendations_pkey" ON public."profileRecommendations" USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX profiles_username_key ON public.profiles USING btree (username);

CREATE UNIQUE INDEX unique_buziness_id ON public."buzinessRecommendations" USING btree (buziness_id, author);

alter table "private"."email_log" add constraint "email_log_pkey" PRIMARY KEY using index "email_log_pkey";

alter table "private"."keys" add constraint "keys_pkey" PRIMARY KEY using index "keys_pkey";

alter table "public"."buziness" add constraint "buziness_pkey" PRIMARY KEY using index "buziness_pkey";

alter table "public"."buzinessRecommendations" add constraint "buzinessRecommendations_pkey" PRIMARY KEY using index "buzinessRecommendations_pkey";

alter table "public"."comments" add constraint "comments_pkey" PRIMARY KEY using index "comments_pkey";

alter table "public"."contacts" add constraint "contacts_pkey" PRIMARY KEY using index "contacts_pkey";

alter table "public"."eventResponses" add constraint "eventResponses_pkey" PRIMARY KEY using index "eventResponses_pkey";

alter table "public"."events" add constraint "events_pkey" PRIMARY KEY using index "events_pkey";

alter table "public"."messages" add constraint "messages_pkey" PRIMARY KEY using index "messages_pkey";

alter table "public"."posts" add constraint "posts_pkey" PRIMARY KEY using index "posts_pkey";

alter table "public"."profileRecommendations" add constraint "profileRecommendations_pkey" PRIMARY KEY using index "profileRecommendations_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "private"."email_log" add constraint "email_log_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "private"."email_log" validate constraint "email_log_user_id_fkey";

alter table "public"."buziness" add constraint "buziness_author_fkey" FOREIGN KEY (author) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."buziness" validate constraint "buziness_author_fkey";

alter table "public"."buziness" add constraint "buziness_author_fkey1" FOREIGN KEY (author) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."buziness" validate constraint "buziness_author_fkey1";

alter table "public"."buziness" add constraint "buziness_defaultContact_fkey" FOREIGN KEY ("defaultContact") REFERENCES public.contacts(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."buziness" validate constraint "buziness_defaultContact_fkey";

alter table "public"."buziness" add constraint "buziness_id_key" UNIQUE using index "buziness_id_key";

alter table "public"."buzinessRecommendations" add constraint "buzinessRecommendations_author_fkey" FOREIGN KEY (author) REFERENCES public.profiles(id) not valid;

alter table "public"."buzinessRecommendations" validate constraint "buzinessRecommendations_author_fkey";

alter table "public"."buzinessRecommendations" add constraint "buzinessRecommendations_author_fkey1" FOREIGN KEY (author) REFERENCES auth.users(id) not valid;

alter table "public"."buzinessRecommendations" validate constraint "buzinessRecommendations_author_fkey1";

alter table "public"."buzinessRecommendations" add constraint "buzinessRecommendations_buziness_id_fkey" FOREIGN KEY (buziness_id) REFERENCES public.buziness(id) ON DELETE CASCADE not valid;

alter table "public"."buzinessRecommendations" validate constraint "buzinessRecommendations_buziness_id_fkey";

alter table "public"."buzinessRecommendations" add constraint "buzinessRecommendations_id_key" UNIQUE using index "buzinessRecommendations_id_key";

alter table "public"."buzinessRecommendations" add constraint "unique_buziness_id" UNIQUE using index "unique_buziness_id";

alter table "public"."comments" add constraint "comments_author_fkey" FOREIGN KEY (author) REFERENCES auth.users(id) not valid;

alter table "public"."comments" validate constraint "comments_author_fkey";

alter table "public"."comments" add constraint "comments_author_fkey1" FOREIGN KEY (author) REFERENCES public.profiles(id) not valid;

alter table "public"."comments" validate constraint "comments_author_fkey1";

alter table "public"."contacts" add constraint "contacts_author_fkey" FOREIGN KEY (author) REFERENCES auth.users(id) not valid;

alter table "public"."contacts" validate constraint "contacts_author_fkey";

alter table "public"."eventResponses" add constraint "eventResponses_event_id_fkey" FOREIGN KEY (event_id) REFERENCES public.events(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."eventResponses" validate constraint "eventResponses_event_id_fkey";

alter table "public"."eventResponses" add constraint "eventResponses_user_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) not valid;

alter table "public"."eventResponses" validate constraint "eventResponses_user_fkey";

alter table "public"."eventResponses" add constraint "event_responses_user_event_unique" UNIQUE using index "event_responses_user_event_unique";

alter table "public"."events" add constraint "events_author_fkey" FOREIGN KEY (author) REFERENCES public.profiles(id) not valid;

alter table "public"."events" validate constraint "events_author_fkey";

alter table "public"."messages" add constraint "messages_author_fkey" FOREIGN KEY (author) REFERENCES auth.users(id) not valid;

alter table "public"."messages" validate constraint "messages_author_fkey";

alter table "public"."messages" add constraint "messages_to_fkey" FOREIGN KEY ("to") REFERENCES auth.users(id) not valid;

alter table "public"."messages" validate constraint "messages_to_fkey";

alter table "public"."posts" add constraint "posts_author_fkey" FOREIGN KEY (author) REFERENCES public.profiles(id) not valid;

alter table "public"."posts" validate constraint "posts_author_fkey";

alter table "public"."profileRecommendations" add constraint "profileRecommendations_author_fkey" FOREIGN KEY (author) REFERENCES public.profiles(id) not valid;

alter table "public"."profileRecommendations" validate constraint "profileRecommendations_author_fkey";

alter table "public"."profileRecommendations" add constraint "profileRecommendations_author_fkey1" FOREIGN KEY (author) REFERENCES auth.users(id) not valid;

alter table "public"."profileRecommendations" validate constraint "profileRecommendations_author_fkey1";

alter table "public"."profileRecommendations" add constraint "profileRecommendations_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES public.profiles(id) not valid;

alter table "public"."profileRecommendations" validate constraint "profileRecommendations_profile_id_fkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."profiles" add constraint "profiles_username_key" UNIQUE using index "profiles_username_key";

alter table "public"."profiles" add constraint "username_length" CHECK ((char_length(username) >= 3)) not valid;

alter table "public"."profiles" validate constraint "username_length";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.check_author_different()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Check if the author of the recommendation is the same as the author of the buziness
    IF EXISTS (
        SELECT 1
        FROM public.buziness
        WHERE id = NEW.buziness_id AND author = NEW.author
    ) THEN
        RAISE EXCEPTION 'Author of the recommendation cannot be the same as the author of the buziness';
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.hybrid_buziness_search(query_text text, query_embedding extensions.vector, lat double precision, long double precision, distance double precision, skip integer, take integer, full_text_weight double precision DEFAULT 0, semantic_weight double precision DEFAULT 1, match_threshold double precision DEFAULT 0.6, rrf_k integer DEFAULT 50)
 RETURNS TABLE(id bigint, title text, description character varying, author uuid, created_at timestamp with time zone, images text[], location extensions.geography, recommendations integer, lat double precision, long double precision, distance double precision, relevance double precision, defaultcontact bigint)
 LANGUAGE sql
AS $function$
  SET search_path TO public; 
  SELECT 
    b.id, b.title, b.description, b.author, b.created_at, b.images, b.location, count(br.id) as recommendations, 
  st_y(location::geometry) as lat,
  st_x(location::geometry) as long,
  st_distance(location, st_point(long, lat)::geography) as distance,
  b.embedding <#> query_embedding as relevance,
  b."defaultContact"
  FROM public.buziness b 
  LEFT OUTER JOIN public."buzinessRecommendations" br
  ON b.id = br.buziness_id
  where 
    case when query_text = '' then true else b.embedding <#> query_embedding < -match_threshold end and    
    case when location = NULL then true else true end
  GROUP BY b.id
  order by case when query_text != '' then (b.embedding <#> query_embedding) end, st_distance(location, st_point(long, lat)::geography) asc
  OFFSET     CASE WHEN skip>=0 THEN skip 
      END ROWS       -- skip 10 rows
  LIMIT CASE WHEN take>=0 THEN take 
      END
$function$
;

CREATE OR REPLACE FUNCTION public.nearby_buziness(lat double precision, long double precision, maxdistance double precision, search character varying, take integer, skip integer)
 RETURNS TABLE(id bigint, title text, description character varying, author uuid, created_at timestamp with time zone, location extensions.geography, recommendations integer, lat double precision, long double precision, distance double precision)
 LANGUAGE sql
AS $function$
  select b.id, b.title, b.description, b.author, b.created_at, b.location, 
  count(br.id) as recommendations,
  st_y(location::geometry) as lat,
  st_x(location::geometry) as long,
  st_distance(location, st_point(long, lat)::geography) as distance
  from public.buziness b left outer join public."buzinessRecommendations" br 
  on b.id = br.buziness_id
  where ( search = '' or (search != '' and b.title &@~ search) )
  group by b.id
  order by count(br.id) desc, b.location <-> st_point(long, lat)::geography
  OFFSET     CASE WHEN skip>=0 THEN skip 
      END ROWS       -- skip 10 rows
  LIMIT CASE WHEN take>=0 THEN take 
      END
$function$
;

CREATE OR REPLACE FUNCTION public.nearby_posts(lat double precision, long double precision, search character varying, skip integer)
 RETURNS TABLE(id bigint, categories character varying, text character varying, author uuid, created_at timestamp with time zone, location extensions.geography, lat double precision, long double precision, distance double precision)
 LANGUAGE sql
AS $function$
  select id, categories, text, author, created_at, location, 
  st_y(location::geometry) as lat,
  st_x(location::geometry) as long,
  st_distance(location, st_point(long, lat)::geography) as distance
  from public.posts
  where search = '' or (search != '' and categories &@~ search)
  order by location <-> st_point(long, lat)::geography;
$function$
;

CREATE OR REPLACE FUNCTION public.newest_buziness(lat double precision, long double precision, distance double precision, skip integer DEFAULT 0, take integer DEFAULT 6, full_text_weight double precision DEFAULT 0, semantic_weight double precision DEFAULT 1, match_threshold double precision DEFAULT 0.8, rrf_k integer DEFAULT 50)
 RETURNS TABLE(id bigint, title text, description character varying, author uuid, created_at timestamp with time zone, images text[], location extensions.geography, recommendations integer, lat double precision, long double precision, distance double precision)
 LANGUAGE sql
AS $function$
  SET search_path TO public; 
  SELECT 
    b.id, b.title, b.description, b.author, b.created_at, b.images, b.location, count(br.id) as recommendations, 
  st_y(location::geometry) as lat,
  st_x(location::geometry) as long,
  st_distance(location, st_point(long, lat)::geography) as distance
  FROM public.buziness b 
  LEFT OUTER JOIN public."buzinessRecommendations" br
  ON b.id = br.buziness_id
  where st_distance(location, st_point(long, lat)::geography) < distance
  GROUP BY b.id
  order by b.created_at desc
  OFFSET CASE WHEN skip>=0 THEN skip 
      END ROWS       -- skip 10 rows
  LIMIT CASE WHEN take>=0 THEN take 
      END
$function$
;

CREATE OR REPLACE FUNCTION public.newest_users(lat double precision, long double precision, distance double precision, skip integer DEFAULT 0, take integer DEFAULT 6, full_text_weight double precision DEFAULT 0, semantic_weight double precision DEFAULT 1, match_threshold double precision DEFAULT 0.8, rrf_k integer DEFAULT 50)
 RETURNS TABLE(id bigint, title text, description character varying, author uuid, created_at timestamp with time zone, images text[], location extensions.geography, recommendations integer, lat double precision, long double precision, distance double precision)
 LANGUAGE sql
AS $function$
  SET search_path TO public; 
  SELECT 
    b.id, b.title, b.description, b.author, b.created_at, b.images, b.location, count(br.id) as recommendations, 
  st_y(location::geometry) as lat,
  st_x(location::geometry) as long,
  st_distance(location, st_point(long, lat)::geography) as distance
  FROM public.buziness b 
  LEFT OUTER JOIN public."buzinessRecommendations" br
  ON b.id = br.buziness_id
  where st_distance(location, st_point(long, lat)::geography) <= distance
  GROUP BY b.id
  order by b.created_at asc
  OFFSET CASE WHEN skip>=0 THEN skip 
      END ROWS       -- skip 10 rows
  LIMIT CASE WHEN take>=0 THEN take 
      END
$function$
;

CREATE OR REPLACE FUNCTION public.send_email_mailersend(message jsonb)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  retval json;
  MAILERSEND_API_TOKEN text;
BEGIN
  SELECT value::text INTO MAILERSEND_API_TOKEN FROM private.keys WHERE key = 'MAILERSEND_API_TOKEN';
  IF NOT found THEN RAISE 'missing entry in private.keys: MAILERSEND_API_TOKEN'; END IF;

    SELECT
        * INTO retval
    FROM
        http 
        ((
            'POST', 
            'https://api.mailersend.com/v1/email', 
            ARRAY[http_header ('Authorization', 
            'Bearer ' || MAILERSEND_API_TOKEN
            ), http_header ('X-Requested-With', 'XMLHttpRequest')], 
            'application/json',
            json_build_object(
                  'from', json_build_object(
                    'email', message->>'sender'
                  ),
                  'to', json_build_array(
                    json_build_object(
                      'email', message->>'recipient'
                    )
                  ),
                  'subject', message->>'subject',
                  'text', message->>'text_body',
                  'html', message->>'html_body' --,
            )::text
          
        ));

  RETURN retval;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$function$
;

grant delete on table "public"."buziness" to "anon";

grant insert on table "public"."buziness" to "anon";

grant references on table "public"."buziness" to "anon";

grant select on table "public"."buziness" to "anon";

grant trigger on table "public"."buziness" to "anon";

grant truncate on table "public"."buziness" to "anon";

grant update on table "public"."buziness" to "anon";

grant delete on table "public"."buziness" to "authenticated";

grant insert on table "public"."buziness" to "authenticated";

grant references on table "public"."buziness" to "authenticated";

grant select on table "public"."buziness" to "authenticated";

grant trigger on table "public"."buziness" to "authenticated";

grant truncate on table "public"."buziness" to "authenticated";

grant update on table "public"."buziness" to "authenticated";

grant delete on table "public"."buziness" to "service_role";

grant insert on table "public"."buziness" to "service_role";

grant references on table "public"."buziness" to "service_role";

grant select on table "public"."buziness" to "service_role";

grant trigger on table "public"."buziness" to "service_role";

grant truncate on table "public"."buziness" to "service_role";

grant update on table "public"."buziness" to "service_role";

grant delete on table "public"."buzinessRecommendations" to "anon";

grant insert on table "public"."buzinessRecommendations" to "anon";

grant references on table "public"."buzinessRecommendations" to "anon";

grant select on table "public"."buzinessRecommendations" to "anon";

grant trigger on table "public"."buzinessRecommendations" to "anon";

grant truncate on table "public"."buzinessRecommendations" to "anon";

grant update on table "public"."buzinessRecommendations" to "anon";

grant delete on table "public"."buzinessRecommendations" to "authenticated";

grant insert on table "public"."buzinessRecommendations" to "authenticated";

grant references on table "public"."buzinessRecommendations" to "authenticated";

grant select on table "public"."buzinessRecommendations" to "authenticated";

grant trigger on table "public"."buzinessRecommendations" to "authenticated";

grant truncate on table "public"."buzinessRecommendations" to "authenticated";

grant update on table "public"."buzinessRecommendations" to "authenticated";

grant delete on table "public"."buzinessRecommendations" to "service_role";

grant insert on table "public"."buzinessRecommendations" to "service_role";

grant references on table "public"."buzinessRecommendations" to "service_role";

grant select on table "public"."buzinessRecommendations" to "service_role";

grant trigger on table "public"."buzinessRecommendations" to "service_role";

grant truncate on table "public"."buzinessRecommendations" to "service_role";

grant update on table "public"."buzinessRecommendations" to "service_role";

grant delete on table "public"."comments" to "anon";

grant insert on table "public"."comments" to "anon";

grant references on table "public"."comments" to "anon";

grant select on table "public"."comments" to "anon";

grant trigger on table "public"."comments" to "anon";

grant truncate on table "public"."comments" to "anon";

grant update on table "public"."comments" to "anon";

grant delete on table "public"."comments" to "authenticated";

grant insert on table "public"."comments" to "authenticated";

grant references on table "public"."comments" to "authenticated";

grant select on table "public"."comments" to "authenticated";

grant trigger on table "public"."comments" to "authenticated";

grant truncate on table "public"."comments" to "authenticated";

grant update on table "public"."comments" to "authenticated";

grant delete on table "public"."comments" to "service_role";

grant insert on table "public"."comments" to "service_role";

grant references on table "public"."comments" to "service_role";

grant select on table "public"."comments" to "service_role";

grant trigger on table "public"."comments" to "service_role";

grant truncate on table "public"."comments" to "service_role";

grant update on table "public"."comments" to "service_role";

grant delete on table "public"."contacts" to "anon";

grant insert on table "public"."contacts" to "anon";

grant references on table "public"."contacts" to "anon";

grant select on table "public"."contacts" to "anon";

grant trigger on table "public"."contacts" to "anon";

grant truncate on table "public"."contacts" to "anon";

grant update on table "public"."contacts" to "anon";

grant delete on table "public"."contacts" to "authenticated";

grant insert on table "public"."contacts" to "authenticated";

grant references on table "public"."contacts" to "authenticated";

grant select on table "public"."contacts" to "authenticated";

grant trigger on table "public"."contacts" to "authenticated";

grant truncate on table "public"."contacts" to "authenticated";

grant update on table "public"."contacts" to "authenticated";

grant delete on table "public"."contacts" to "service_role";

grant insert on table "public"."contacts" to "service_role";

grant references on table "public"."contacts" to "service_role";

grant select on table "public"."contacts" to "service_role";

grant trigger on table "public"."contacts" to "service_role";

grant truncate on table "public"."contacts" to "service_role";

grant update on table "public"."contacts" to "service_role";

grant delete on table "public"."eventResponses" to "anon";

grant insert on table "public"."eventResponses" to "anon";

grant references on table "public"."eventResponses" to "anon";

grant select on table "public"."eventResponses" to "anon";

grant trigger on table "public"."eventResponses" to "anon";

grant truncate on table "public"."eventResponses" to "anon";

grant update on table "public"."eventResponses" to "anon";

grant delete on table "public"."eventResponses" to "authenticated";

grant insert on table "public"."eventResponses" to "authenticated";

grant references on table "public"."eventResponses" to "authenticated";

grant select on table "public"."eventResponses" to "authenticated";

grant trigger on table "public"."eventResponses" to "authenticated";

grant truncate on table "public"."eventResponses" to "authenticated";

grant update on table "public"."eventResponses" to "authenticated";

grant delete on table "public"."eventResponses" to "service_role";

grant insert on table "public"."eventResponses" to "service_role";

grant references on table "public"."eventResponses" to "service_role";

grant select on table "public"."eventResponses" to "service_role";

grant trigger on table "public"."eventResponses" to "service_role";

grant truncate on table "public"."eventResponses" to "service_role";

grant update on table "public"."eventResponses" to "service_role";

grant delete on table "public"."events" to "anon";

grant insert on table "public"."events" to "anon";

grant references on table "public"."events" to "anon";

grant select on table "public"."events" to "anon";

grant trigger on table "public"."events" to "anon";

grant truncate on table "public"."events" to "anon";

grant update on table "public"."events" to "anon";

grant delete on table "public"."events" to "authenticated";

grant insert on table "public"."events" to "authenticated";

grant references on table "public"."events" to "authenticated";

grant select on table "public"."events" to "authenticated";

grant trigger on table "public"."events" to "authenticated";

grant truncate on table "public"."events" to "authenticated";

grant update on table "public"."events" to "authenticated";

grant delete on table "public"."events" to "service_role";

grant insert on table "public"."events" to "service_role";

grant references on table "public"."events" to "service_role";

grant select on table "public"."events" to "service_role";

grant trigger on table "public"."events" to "service_role";

grant truncate on table "public"."events" to "service_role";

grant update on table "public"."events" to "service_role";

grant delete on table "public"."messages" to "anon";

grant insert on table "public"."messages" to "anon";

grant references on table "public"."messages" to "anon";

grant select on table "public"."messages" to "anon";

grant trigger on table "public"."messages" to "anon";

grant truncate on table "public"."messages" to "anon";

grant update on table "public"."messages" to "anon";

grant delete on table "public"."messages" to "authenticated";

grant insert on table "public"."messages" to "authenticated";

grant references on table "public"."messages" to "authenticated";

grant select on table "public"."messages" to "authenticated";

grant trigger on table "public"."messages" to "authenticated";

grant truncate on table "public"."messages" to "authenticated";

grant update on table "public"."messages" to "authenticated";

grant delete on table "public"."messages" to "service_role";

grant insert on table "public"."messages" to "service_role";

grant references on table "public"."messages" to "service_role";

grant select on table "public"."messages" to "service_role";

grant trigger on table "public"."messages" to "service_role";

grant truncate on table "public"."messages" to "service_role";

grant update on table "public"."messages" to "service_role";

grant delete on table "public"."posts" to "anon";

grant insert on table "public"."posts" to "anon";

grant references on table "public"."posts" to "anon";

grant select on table "public"."posts" to "anon";

grant trigger on table "public"."posts" to "anon";

grant truncate on table "public"."posts" to "anon";

grant update on table "public"."posts" to "anon";

grant delete on table "public"."posts" to "authenticated";

grant insert on table "public"."posts" to "authenticated";

grant references on table "public"."posts" to "authenticated";

grant select on table "public"."posts" to "authenticated";

grant trigger on table "public"."posts" to "authenticated";

grant truncate on table "public"."posts" to "authenticated";

grant update on table "public"."posts" to "authenticated";

grant delete on table "public"."posts" to "service_role";

grant insert on table "public"."posts" to "service_role";

grant references on table "public"."posts" to "service_role";

grant select on table "public"."posts" to "service_role";

grant trigger on table "public"."posts" to "service_role";

grant truncate on table "public"."posts" to "service_role";

grant update on table "public"."posts" to "service_role";

grant delete on table "public"."profileRecommendations" to "anon";

grant insert on table "public"."profileRecommendations" to "anon";

grant references on table "public"."profileRecommendations" to "anon";

grant select on table "public"."profileRecommendations" to "anon";

grant trigger on table "public"."profileRecommendations" to "anon";

grant truncate on table "public"."profileRecommendations" to "anon";

grant update on table "public"."profileRecommendations" to "anon";

grant delete on table "public"."profileRecommendations" to "authenticated";

grant insert on table "public"."profileRecommendations" to "authenticated";

grant references on table "public"."profileRecommendations" to "authenticated";

grant select on table "public"."profileRecommendations" to "authenticated";

grant trigger on table "public"."profileRecommendations" to "authenticated";

grant truncate on table "public"."profileRecommendations" to "authenticated";

grant update on table "public"."profileRecommendations" to "authenticated";

grant delete on table "public"."profileRecommendations" to "service_role";

grant insert on table "public"."profileRecommendations" to "service_role";

grant references on table "public"."profileRecommendations" to "service_role";

grant select on table "public"."profileRecommendations" to "service_role";

grant trigger on table "public"."profileRecommendations" to "service_role";

grant truncate on table "public"."profileRecommendations" to "service_role";

grant update on table "public"."profileRecommendations" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";


  create policy "Enable read access for all users"
  on "public"."buziness"
  as permissive
  for select
  to public
using (true);



  create policy "Enable select, insert, update, delete for author"
  on "public"."buziness"
  as permissive
  for all
  to authenticated
using ((( SELECT auth.uid() AS uid) = author));



  create policy "Enable delete for users based on user_id"
  on "public"."buzinessRecommendations"
  as permissive
  for all
  to public
using ((( SELECT auth.uid() AS uid) = author))
with check ((( SELECT auth.uid() AS uid) = author));



  create policy "Enable read access for all users"
  on "public"."buzinessRecommendations"
  as permissive
  for select
  to public
using (true);



  create policy "Enable delete for users based on user_id"
  on "public"."comments"
  as permissive
  for delete
  to public
using ((( SELECT auth.uid() AS uid) = author));



  create policy "Enable insert for users based on user_id"
  on "public"."comments"
  as permissive
  for insert
  to public
with check ((( SELECT auth.uid() AS uid) = author));



  create policy "Enable read access for all users"
  on "public"."comments"
  as permissive
  for select
  to public
using (true);



  create policy "Enable update for users based on email"
  on "public"."comments"
  as permissive
  for update
  to public
using ((( SELECT auth.uid() AS uuid) = author));



  create policy "Enable read access for all users"
  on "public"."contacts"
  as permissive
  for select
  to public
using (true);



  create policy "edit if user's"
  on "public"."contacts"
  as permissive
  for all
  to public
using ((author = auth.uid()))
with check ((author = auth.uid()));



  create policy "Enable all for authenticated users only"
  on "public"."eventResponses"
  as permissive
  for all
  to authenticated
using (true);



  create policy "Enable read access for all users"
  on "public"."events"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Edit for Author"
  on "public"."profileRecommendations"
  as permissive
  for all
  to public
using ((( SELECT auth.uid() AS uid) = author))
with check ((( SELECT auth.uid() AS uid) = author));



  create policy "Enable read access for all users"
  on "public"."profileRecommendations"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Public profiles are viewable by everyone."
  on "public"."profiles"
  as permissive
  for select
  to public
using (true);



  create policy "Users can insert their own profile."
  on "public"."profiles"
  as permissive
  for insert
  to public
with check ((( SELECT auth.uid() AS uid) = id));



  create policy "Users can update own profile."
  on "public"."profiles"
  as permissive
  for update
  to public
using ((( SELECT auth.uid() AS uid) = id));


CREATE TRIGGER enforce_author_different BEFORE INSERT OR UPDATE ON public."buzinessRecommendations" FOR EACH ROW EXECUTE FUNCTION public.check_author_different();

CREATE TRIGGER send_notification_on_new_event AFTER INSERT OR UPDATE ON public.events FOR EACH ROW EXECUTE FUNCTION supabase_functions.http_request('https://pdzuvfkkrhtrrrcckwzj.supabase.co/functions/v1/push', 'POST', '{"Content-type":"application/json"}', '{}', '5000');


  create policy "Authed users can edit their own folder 1oj01fe_0"
  on "storage"."objects"
  as permissive
  for insert
  to public
with check (((bucket_id = 'avatars'::text) AND ((storage.foldername(name))[1] = ( SELECT (auth.uid())::text AS uid))));



  create policy "Authed users can edit their own folder 1oj01fe_1"
  on "storage"."objects"
  as permissive
  for update
  to public
using (((bucket_id = 'avatars'::text) AND ((storage.foldername(name))[1] = ( SELECT (auth.uid())::text AS uid))));



  create policy "Authed users can edit their own folder 1oj01fe_2"
  on "storage"."objects"
  as permissive
  for delete
  to public
using (((bucket_id = 'avatars'::text) AND ((storage.foldername(name))[1] = ( SELECT (auth.uid())::text AS uid))));



  create policy "Authed users can get avatars 1oj01fe_0"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using (((bucket_id = 'avatars'::text) AND (auth.role() = 'authenticated'::text)));



  create policy "Give users access to own folder 17biuwh_0"
  on "storage"."objects"
  as permissive
  for insert
  to public
with check (((bucket_id = 'buzinessImages'::text) AND (( SELECT (auth.uid())::text AS uid) = (storage.foldername(name))[1])));



  create policy "Give users access to own folder 17biuwh_1"
  on "storage"."objects"
  as permissive
  for update
  to public
using (((bucket_id = 'buzinessImages'::text) AND (( SELECT (auth.uid())::text AS uid) = (storage.foldername(name))[1])));



  create policy "Give users access to own folder 17biuwh_2"
  on "storage"."objects"
  as permissive
  for delete
  to public
using (((bucket_id = 'buzinessImages'::text) AND (( SELECT (auth.uid())::text AS uid) = (storage.foldername(name))[1])));



  create policy "Give users access to own folder 1p2g73o_0"
  on "storage"."objects"
  as permissive
  for select
  to public
using (((bucket_id = 'comments'::text) AND (( SELECT (auth.uid())::text AS uid) = (storage.foldername(name))[1])));



  create policy "Give users access to own folder 1p2g73o_1"
  on "storage"."objects"
  as permissive
  for insert
  to public
with check (((bucket_id = 'comments'::text) AND (( SELECT (auth.uid())::text AS uid) = (storage.foldername(name))[1])));



  create policy "Give users access to own folder 1p2g73o_2"
  on "storage"."objects"
  as permissive
  for delete
  to public
using (((bucket_id = 'comments'::text) AND (( SELECT (auth.uid())::text AS uid) = (storage.foldername(name))[1])));



  create policy "Give users authenticated access to folder 17biuwh_0"
  on "storage"."objects"
  as permissive
  for select
  to public
using (((bucket_id = 'buzinessImages'::text) AND (auth.role() = 'authenticated'::text)));



